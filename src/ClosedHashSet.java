/** * A hash-set based on closed-hashing with quadratic probing. Extends SimpleHashSet */public class ClosedHashSet extends SimpleHashSet {    /* Class members - variables */    private String[] table = new String[INITIAL_CAPACITY]; // Hash table representation.    private boolean[] ignoreList = new boolean[INITIAL_CAPACITY]; // Ignore list boolean array to hold deleted indexes.    private int elementCounter = 0; // Table's element counter. Updated on each successful add/delete.    /* Constructors */    /**     * A default constructor. Constructs a new, empty table with default initial capacity (16),     * upper load factor (0.75) and lower load factor (0.25).     */    public ClosedHashSet() {        super();    }    /**     * Constructs a new, empty table with the specified load factors, and the default initial capacity (16).     *     * @param upperLoadFactor The upper load factor of the hash table.     * @param lowerLoadFactor The lower load factor of the hash table.     */    public ClosedHashSet(float upperLoadFactor, float lowerLoadFactor) {        super(upperLoadFactor, lowerLoadFactor);    }    /**     * Data constructor - builds the hash set by adding the elements one by one. Duplicate values should be ignored.     * The new table has the default values of initial capacity (16), upper load factor (0.75),     * and lower load factor (0.25).     *     * @param data Values to add to the set.     */    public ClosedHashSet(String[] data) {        super();        for (String item : data)            this.add(item);    }    /* Public instance Methods */    /**     * Add a specified element to the set if it's not already in it.     *     * @param newValue New value to add to the set     * @return False iff newValue already exists in the set.     */    public boolean add(String newValue) {        int predictResize = this.predictResize(newValue); // Assign resize simulation test result to int.        // If result states that resize is needed and item is not in table yet, performs resize and return true.        if (predictResize == 1) {            this.elementCounter++; // Appends element counter by 1;            if (this.shouldIncrease()) {                this.resize(true, newValue);                return true;            }            // If resize was needed but item exists in table, do nothing and return false.        } else if (predictResize == -1)            return false;        // Iterates over probing index, until empty slot found.        for (int i = 0; i < this.table.length; i++) {            int index = this.clamp(this.hash(newValue, i)); // Clamps string hash code to fit array index.            // If index is null, assign item to index and return true.            if (this.table[index] == null) {                this.elementCounter++; // Appends element counter by 1;                this.table[index] = newValue;                if (this.ignoreList[index])                    this.ignoreList[index] = false; // If index in ignore list, remove it from there.                return true;                // If item exists in table, do nothing and return false.            } else if (this.table[index].equals(newValue))                return false;        }        return false;    }    /**     * Look for a specified value in the set.     *     * @param searchVal Value to search for     * @return True iff searchVal is found in the set.     */    public boolean contains(String searchVal) {        // Iterates over probing index, until relevant slot found or iteration reached null slot.        for (int i = 0; i < this.table.length; i++) {            int index = this.clamp(this.hash(searchVal, i)); // Clamps string hash code to fit array index.            // Null slot reached, item not in table, return false.            if (this.ignoreList[index])                continue;            else if (this.table[index] == null)                return false;                // Index equals search val, item found, return true.            else if (this.table[index].equals(searchVal))                return true;        }        return false; // If iteration completed and no null or equal val found.    }    /**     * Remove the input element from the set.     *     * @param toDelete Value to delete     * @return True iff toDelete is found and deleted.     */    public boolean delete(String toDelete) {        for (int i = 0; i < this.table.length; i++) {            int index = this.clamp(this.hash(toDelete, i)); // Clamps string hash code to fit array index.            // Null slot reached, item not in table therefore cannot be deleted, return false.            if (this.ignoreList[index])                continue;            else if (this.table[index] == null)                return false;                // Index equals search val, item found: delete it, re-hash table and return true.            else if (this.table[index].equals(toDelete)) {                this.table[index] = null; // Delete index value.                this.ignoreList[index] = true;                this.elementCounter--; // Removes 1 from element counter.                if (this.shouldDecrease())                    this.resize(false, toDelete); // Checks if decrease-resizing is needed.                return true;            }        }        return false;    }    /**     * @return The number of elements currently in the set.     */    public int size() {        return this.elementCounter;    }    /**     * Specified by: capacity in class SimpleHashSet.     *     * @return The current capacity (number of cells) of the table.     */    public int capacity() {        return this.table.length;    }    /* Protected instance Methods */    /**     * Calls super method and adds ignore list reinitialization.     *     * @param increase True if increase is performed, False if decrease.     * @param lastItem Item that was added/deleted before table resize.     */    @Override    protected void resize(boolean increase, String lastItem) {        int newCapacity = increase ? this.capacity() * 2 : this.capacity() / 2;        this.ignoreList = new boolean[newCapacity];        super.resize(increase, lastItem);    }    /**     * Reinitialize hash table based on new capacity.     *     * @param newCapacity New table capacity.     */    protected void newTable(int newCapacity) {        this.table = new String[newCapacity]; // Creates new empty table with specified capacity.    }    /**     * Creates an array representation of the current table elements (no duplicates, no null).     *     * @return Array that contains all String elements in the current table.     */    protected String[] assignTableElementsToArray() {        String[] tempTable = new String[this.size()]; // Assign new array the size of total elements in table.        int index = 0;        for (String item : this.table) // Go over all the String items of the table.            // If index not null, assign String to the result array.            if (item != null) {                tempTable[index] = item;                index++;            }        return tempTable;    }    /**     * Adds String element (no duplicates, no null) to new resized table.     *     * @param item Element to add.     */    protected void addUnique(String item) {        // Iterates over probing index, until empty slot found.        for (int i = 0; i < this.table.length; i++) {            int index = this.clamp(this.hash(item, i)); // Clamps string hash code to fit array index.            // If index is null, assign item to index and return true.            if (this.table[index] == null) {                this.table[index] = item;                return;            }        }    }    /* Private instance Methods */    /**     * @param item  String to hash.     * @param index Index of current probing.     * @return Hash code for String input, based on quadratic probing algorithm.     */    private int hash(String item, int index) {        return item.hashCode() + ((index + index * index) / 2);    }    /**     * Checks when adding a new item if this addition will require a resize.     *     * @param item The new item to add.     * @return (1) If adding the item indeed requires a resize && item is not in the table already.     * (0) If adding the item doesn't require a resize.     * (-1) If item is already in the table.     */    private int predictResize(String item) {        if (!addSimulation())            return 0; // If when adding a dummy-item a resize is not needed.        else if (this.contains(item))            return -1; // If a resize is needed, but item already in the table.        return 1; // If a resize is needed, and item is not already in the table.    }    /**     * Helper for predictResize() method. Simulates adding an item to the counter and checks if then resize is required.     *     * @return True if resize is required with this item added, false if otherwise.     */    private boolean addSimulation() {        this.elementCounter++; // Add dummy-item to the counter.        boolean result = this.shouldIncrease(); // Assign to boolean if in the current situation, a resize is needed.        this.elementCounter--; // Removes the dummy-item from the counter.        return result; // Return the simulation result.    }}